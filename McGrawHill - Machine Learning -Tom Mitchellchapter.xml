<?xml version='1.0' encoding='UTF-8'?>
<pdfx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pdfx.cs.man.ac.uk/static/article-schema.xsd">
  <meta>
    <job>b1da1ac968c25aee7f0676190f03a939977fa8faa41d7d9c3341cde78d02d6a3</job>
    <base_name>11ez</base_name>
    <doi>http://dx.doi.org/10.1037/t39014-000</doi>
    <warning>Name identification was not possible. </warning>
    <warning>Original PDF was found to be an image-based/possible OCR document. Output quality may be degraded.</warning>
  </meta>
  <article>
    <front class="DoCO:FrontMatter">
      <outsider class="DoCO:TextBox" type="header" id="1">CHAPTER 1 INTRODUCITON</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="2">3</outsider>
      <region class="DoCO:TextChunk" id="3" confidence="possible">0 Learning to recognize spoken words. All of the most successful speech recognition systems employ machine learning in some form. For example, the SPHINX system (e.g., Lee 1989) learns speaker-specific strategies for recognizing the primitive sounds (phonemes) and words from the observed speech signal. Neural network learning methods (e.g., Waibel et al. 1989) and methods for learning hidden Markov models (e.g., Lee 1989) are effective for automatically customizing to,individual speakers, vocabularies, microphone characteristics, background noise, etc. Similar techniques have potential applications in many signal-interpretation problems. 0 Learning to drive an autonomous vehicle. Machine learning methods have been used to train computer-controlled vehicles to steer correctly when driving on a variety of road types. For example, the ALVINN system (Pomerleau 1989) has used its learned strategies to drive unassisted at 70 miles per hour for 90 miles on public highways among other cars. Similar techniques have possible applications in many sensor-based control problems. 0 Learning to classify new astronomical structures. Machine learning methods have been applied to a variety of large databases to learn general regularities implicit in the data. For example, decision tree learning algorithms have been used by NASA to learn how to classify celestial objects from the second Palomar Observatory Sky Survey (Fayyad et al. 1995). This system is now used to automatically classify all objects in the Sky Survey, which consists of three terrabytes of image data. 0 Learning to play world-class backgammon. The most successful computer programs for playing games such as backgammon are based on machiie learning algorithms. For example, the world's top computer program for backgammon, TD-GAMMON (Tesauro 1992, 1995). learned its strategy by playing over one million practice games against itself. It now plays at a level competitive with the human world champion. Similar techniques have applications in many practical problems where very large search spaces must be examined efficiently.</region>
      <region class="unknown" id="5"> <xref ref-type="table" rid="T1" id="4" class="deo:Reference">TABLE 1</xref> . 1 Some successful applications of machiie learning.</region>
      <title-group>
        <article-title class="DoCO:Title" id="7" confidence="possible">three features: the class of tasks, the measure of performance to be improved, and the source of experience.</article-title>
      </title-group>
    </front>
    <body class="DoCO:BodyMatter">
      <region class="DoCO:TextChunk" id="6" page="1" column="1">three features: the class of tasks, the measure of performance to be improved, and the source of experience.</region>
      <region class="unknown" id="8" page="1" column="1">A checkers learning problem:</region>
      <region class="unknown" id="9" page="1" column="1">0</region>
      <region class="DoCO:TextChunk" id="10" confidence="possible" page="1" column="1">Task T: playing checkers Performance measure P: percent of games won against opponents Training experience E: playing practice games against itself</region>
      <region class="DoCO:TextChunk" id="11" page="1" column="1">We can specify many learning problems in this fashion, such as learning to recognize handwritten words, or learning to drive a robotic automobile autonomously.</region>
      <region class="unknown" id="12" page="1" column="1">A handwriting recognition learning problem:</region>
      <region class="unknown" id="13" page="1" column="1">0</region>
      <region class="unknown" id="14" page="1" column="1">0</region>
      <region class="DoCO:TextChunk" id="15" confidence="possible" page="1" column="1">Task T: recognizing and classifying handwritten words within images Performance measure P : percent of words correctly classified</region>
      <region class="DoCO:FigureBox" id="Fx16">
        <image class="DoCO:Figure" src="11ez.page_001.image_01.png" thmb="11ez.page_001.image_01-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="17" page="2" column="1">4</outsider>
      <outsider class="DoCO:TextBox" type="header" id="18" page="2" column="1">MACHINE LEARNING</outsider>
      <region class="DoCO:TextChunk" id="19" confidence="possible" page="2" column="1">Artificial intelligence Learning symbolic representations of concepts. Machine learning as a search problem. Learning as an approach to improving problem solving. Using prior knowledge together with training data to guide learning. 0 Bayesian methods Bayes' theorem as the basis for calculating probabilities of hypotheses. The naive Bayes classifier. Algorithms for estimating values of unobserved variables. 0 Computational complexity theory Theoretical bounds on the inherent complexity of different learning tasks, measured in terms of the computational effort, number of training examples, number of mistakes, etc. required in order to learn. Control theory Procedures that learn to control processes in order to optimize predefined objectives and that learn to predict the next state of the process they are controlling. 0 Information theory Measures of entropy and information content. Minimum description length approaches to learning. Optimal codes and their relationship to optimal training sequences for encoding a hypothesis. Philosophy Occam's razor, suggesting that the simplest hypothesis is the best. Analysis of the justification for generalizing beyond observed data. 0 Psychology and neurobiology The power law of practice, which states that over a very broad range of learning problems, people's response time improves with practice according to a power law. Neurobiological studies motivating artificial neural network models of learning. 0 Statistics Characterization of errors (e.g., bias and variance) that occur when estimating the accuracy of a hypothesis based on a limited sample of data. Confidence intervals, statistical tests.</region>
      <region class="DoCO:TableBox" id="T1.2">
        <caption class="deo:Caption" id="20" page="2" column="1">TABLE 1.2</caption>
      </region>
      <region class="unknown" id="21" page="2" column="1">Some disciplines and examples of their influence on machine learning.</region>
      <region class="unknown" id="22" page="2" column="1">0 E:</region>
      <region class="DoCO:TextChunk" id="23" confidence="possible" page="2" column="1">Training experience a database of handwritten words with given classifications</region>
      <region class="unknown" id="24" page="2" column="1">A robot driving learning problem:</region>
      <region class="unknown" id="25" page="2" column="1">0</region>
      <region class="unknown" id="26" page="2" column="1">0</region>
      <region class="unknown" id="27" page="2" column="1">0</region>
      <region class="DoCO:TextChunk" id="28" confidence="possible" page="2" column="1">Task T: driving on public four-lane highways using vision sensors Performance measure P: average distance traveled before an error (as judged by human overseer) Training experience E: a sequence of images and steering commands record- ed while observing a human driver</region>
      <region class="DoCO:TextChunk" id="39" page="2" column="1">Our definition of learning is broad enough to include most tasks that we would conventionally call "learning" tasks, as we use the word in everyday language. It is also broad enough to encompass computer programs that improve from experience in quite straightforward ways. For example, a database system <marker type="page" number="3"/><marker type="block"/> that allows users to update data entries would fit our definition of a learning system: it improves its performance at answering database queries, based on the experience gained from database updates. Rather than worry about whether this type of activity falls under the usual informal conversational meaning of the word "learning," we will simply adopt our technical definition of the class of programs that improve through experience. Within this class we will find many types of problems that require more or less sophisticated solutions. Our concern here is not to analyze the meaning of the English word "learning" as it is used in everyday language. Instead, our goal is to define precisely a class of problems that encompasses interesting forms of learning, to explore algorithms that solve such problems, and to understand the fundamental structure of learning problems and processes.<marker type="block"/> In order to illustrate some of the basic design issues and approaches to machine learning, let us consider designing a program to learn to play checkers, with the goal of entering it in the world checkers tournament. We adopt the obvious performance measure: the percent of games it wins in this world tournament.<marker type="block"/> The first design choice we face is to choose the type of training experience from which our system will learn. The type of training experience available can have a significant impact on success or failure of the learner. One key attribute is whether the training experience provides direct or indirect feedback regarding the choices made by the performance system. For example, in learning to play checkers, the system might learn from direct training examples consisting of individual checkers board states and the correct move for each. Alternatively, it might have available only indirect information consisting of the move sequences and final outcomes of various games played. In this later case, information about the correctness of specific moves early in the game must be inferred indirectly from the fact that the game was eventually won or lost. Here the learner faces an additional problem of credit assignment, or determining the degree to which each move in the sequence deserves credit or blame for the final outcome. Credit assignment can be a particularly difficult problem because the game can be lost even when early moves are optimal, if these are followed later by poor moves. Hence, learning from direct training feedback is typically easier than learning from indirect feedback. A second important attribute of the training experience is the degree to which the learner controls the sequence of training examples. For example, the learner might rely on the teacher to select informative board states and to provide the correct move for each. Alternatively, the learner might itself propose board states that it finds particularly confusing and ask the teacher for the correct move. Or the learner may have complete control over both the board states and (indirect) training classifications, as it does when it learns by playing against itself with no teacher<marker type="page" number="4"/><marker type="block"/> present. Notice in this last case the learner may choose between experimenting with novel board states that it has not yet considered, or honing its skill by playing minor variations of lines of play it currently finds most promising. Subsequent chapters consider a number of settings for learning, including settings in which training experience is provided by a random process outside the learner's control, settings in which the learner may pose various types of queries to an expert teacher, and settings in which the learner collects training examples by autonomously exploring its environment. A third important attribute of the training experience is how well it represents the distribution of examples over which the final system performance P must be measured. In general, learning is most reliable when the training examples fol- low a distribution similar to that of future test examples. In our checkers learning scenario, the performance metric P is the percent of games the system wins in the world tournament. If its training experience E consists only of games played against itself, there is an obvious danger that this training experience might not be fully representative of the distribution of situations over which it will later be tested. For example, the learner might never encounter certain crucial board states that are very likely to be played by the human checkers champion. In practice, it is often necessary to learn from a distribution of examples that is somewhat different from those on which the final system will be evaluated (e.g., the world checkers champion might not be interested in teaching the program!). Such situations are problematic because mastery of one distribution of examples will not necessary lead to strong performance over some other distribution. We shall see that most current theory of machine learning rests on the crucial assumption that the distribution of training examples is identical to the distribution of test examples. Despite our need to make this assumption in order to obtain theoretical results, it is important to keep in mind that this assumption must often be violated in practice. To proceed with our design, let us decide that our system will train by playing games against itself. This has the advantage that no external trainer need be present, and it therefore allows the system to generate as much training data as time permits. We now have a fully specified learning task.</region>
      <region class="DoCO:FigureBox" id="Fx30">
        <image class="DoCO:Figure" src="11ez.page_002.image_02.png" thmb="11ez.page_002.image_02-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="header" id="31" page="3" column="1">CHAFTlB 1 INTRODUCTION</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="32" page="3" column="1">5</outsider>
      <region class="unknown" id="34" page="3" column="1">1.2 DESIGNING A LEARNING SYSTEM</region>
      <region class="unknown" id="36" page="3" column="1">1.2.1 Choosing the Training Experience</region>
      <region class="DoCO:FigureBox" id="Fx38">
        <image class="DoCO:Figure" src="11ez.page_003.image_03.png" thmb="11ez.page_003.image_03-thumb.png"/>
      </region>
      <region class="unknown" id="40" page="4" column="1">A checkers learning problem:</region>
      <region class="unknown" id="41" page="4" column="1">0</region>
      <region class="unknown" id="42" page="4" column="1">0</region>
      <region class="unknown" id="43" page="4" column="1">0</region>
      <region class="DoCO:TextChunk" id="44" confidence="possible" page="4" column="1">Task T: playing checkers Performance measure P: percent of games won in the world tournament Training experience E: games played against itself</region>
      <region class="DoCO:TextChunk" id="45" confidence="possible" page="4" column="1">In order to complete the design of the learning system, we must now choose</region>
      <region class="DoCO:TextChunk" id="46" confidence="possible" page="4" column="1">1. the exact type of knowledge to be,learned 2. a representation for this target knowledge 3 . a learning mechanism</region>
      <region class="DoCO:FigureBox" id="Fx47">
        <image class="DoCO:Figure" src="11ez.page_004.image_04.png" thmb="11ez.page_004.image_04-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="header" id="48" page="5" column="1">CHAFTER I INTRODUCTION</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="49" page="5" column="1">7</outsider>
      <region class="unknown" id="50" page="5" column="1">1.2.2 Choosing the Target Function</region>
      <region class="DoCO:TextChunk" id="51" page="5" column="1">The next design choice is to determine exactly what type of knowledge will be learned and how this will be used by the performance program. Let us begin with a checkers-playing program that can generate the legal moves from any board state. The program needs only to learn how to choose the best move from among these legal moves. This learning task is representative of a large class of tasks for which the legal moves that define some large search space are known a priori, but for which the best search strategy is not known. Many optimization problems fall into this class, such as the problems of scheduling and controlling manufacturing processes where the available manufacturing steps are well understood, but the best strategy for sequencing them is not. Given this setting where we must learn to choose among the legal moves, the most obvious choice for the type of information to be learned is a program, or function, that chooses the best move for any given board state. Let us call this function ChooseMove and use the notation ChooseMove : B -+ M to indicate that this function accepts as input any board from the set of legal board states B and produces as output some move from the set of legal moves M. Throughout our discussion of machine learning we will find it useful to reduce the problem of improving performance P at task T to the problem of learning some particular targetfunction such as ChooseMove. The choice of the target function will therefore be a key design choice. Although ChooseMove is an obvious choice for the target function in our example, this function will turn out to be very difficult to learn given the kind of indirect training experience available to our system. An alternative target function- and one that will turn out to be easier to learn in this setting-is an evaluation function that assigns a numerical score to any given board state. Let us call this target function V and again use the notation V : B + 8 to denote that V maps any legal board state from the set B to some real value (we use 8 to denote the set of real numbers). We intend for this target function V to assign higher scores to better board states. If the system can successfully learn such a target function V , then it can easily use it to select the best move from any current board position. This can be accomplished by generating the successor board state produced by every legal move, then using V to choose the best successor state and therefore the best legal move. What exactly should be the value of the target function V for any given board state? Of course any evaluation function that assigns higher scores to better board states will do. Nevertheless, we will find it useful to define one particular target function V among the many that produce optimal play. As we shall see, this will make it easier to design a training algorithm. Let us therefore define the target value V ( b ) for an arbitrary board state b in B , as follows:</region>
      <region class="DoCO:TextChunk" id="52" confidence="possible" page="5" column="1">100 -100</region>
      <region class="unknown" id="53" page="5" column="1">1. b 2. if b 3. b</region>
      <region class="DoCO:TextChunk" id="54" confidence="possible" page="5" column="1">if is a final board state that is won, then is a final board state that is lost, then V if is a final board state that is drawn, then</region>
      <region class="unknown" id="55" page="5" column="1">V ( b ) = ( b ) = V ( b ) = 0</region>
      <region class="DoCO:FigureBox" id="Fx56">
        <image class="DoCO:Figure" src="11ez.page_005.image_05.png" thmb="11ez.page_005.image_05-thumb.png"/>
      </region>
      <region class="DoCO:TextChunk" id="57" confidence="possible" page="6" column="1">4. if b is a not a final state in the game, then V(b) = V(bl), where b' is the best final board state that can be achieved starting from b and playing optimally until the end of the game (assuming the opponent plays optimally, as well).</region>
      <region class="DoCO:TextChunk" id="60" page="6" column="1">While this recursive definition specifies a value of V(b) for every board state b, this definition is not usable by our checkers player because it is not efficiently computable. Except for the trivial cases (cases 1-3) in which the game has already ended, determining the value of V(b) for a particular board state requires (case 4) searching ahead for the optimal line of play, all the way to the end of the game! Because this definition is not efficiently computable by our checkers playing program, we say that it is a nonoperational definition. The goal of learning in this case is to discover an operational description of V ; that is, a description that can be used by the checkers-playing program to evaluate states and select moves within realistic time bounds. Thus, we have reduced the learning task in this case to the problem of discovering an operational description of the ideal targetfunction V. It may be very difficult in general to learn such an operational form of V perfectly. In fact, we often expect learning algorithms to acquire only some approximation to the target function, and for this reason the process of learning the target function is often called function approximation. In the current discussion we will use the symbol ? to refer to the function that is actually learned by our program, to distinguish it from the ideal target function V. <marker type="block"/> Now that we have specified the ideal target function V, we must choose a representation that the learning program will use to describe the function c that it will learn. As with earlier design choices, we again have many options. We could, for example, allow the program to represent using a large table with a distinct entry specifying the value for each distinct board state. Or we could allow it to represent using a collection of rules that match against features of the board state, or a quadratic polynomial function of predefined board features, or an artificial neural network. In general, this choice of representation involves a crucial tradeoff. On one hand, we wish to pick a very expressive representation to allow representing as close an approximation as possible to the ideal target function V. On the other hand, the more expressive the representation, the more training data the program will require in order to choose among the alternative hypotheses it can represent. To keep the discussion brief, let us choose a simple representation: for any given board state, the function c will be calculated as a linear combination of the following board features:</region>
      <region class="unknown" id="59" page="6" column="1">1.23 Choosing a Representation for the Target Function</region>
      <region class="unknown" id="61" page="6" column="1">0 xl: x2: 0 xs: 0 x4:</region>
      <region class="DoCO:TextChunk" id="62" confidence="possible" page="6" column="1">the number of black pieces on the board the number of red pieces on the board the number of black kings on the board the number of red kings on the board</region>
      <region class="DoCO:FigureBox" id="Fx63">
        <image class="DoCO:Figure" src="11ez.page_006.image_06.png" thmb="11ez.page_006.image_06-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="header" id="64" page="7" column="1">CHAPTER I INTRODUCTION</outsider>
      <outsider class="DoCO:TextBox" type="page_nr" id="65" page="7" column="1">9</outsider>
      <region class="DoCO:TextChunk" id="66" confidence="possible" page="7" column="1">x5: the number of black pieces threatened by red (i.e., which can be captured on red's next turn) X6: the number of red pieces threatened by black</region>
      <region class="DoCO:TextChunk" id="68" page="7" column="1">Thus, our learning program will represent c(b) as a linear function of the form <marker type="block"/> where wo through W6 are numerical coefficients, or weights, to be chosen by the learning algorithm. Learned values for the weights w l through W6 will determine the relative importance of the various board features in determining the value of the board, whereas the weight wo will provide an additive constant to the board value. To summarize our design choices thus far, we have elaborated the original formulation of the learning problem by choosing a type of training experience, a target function to be learned, and a representation for this target function. Our elaborated learning task is now</region>
      <region class="unknown" id="69" page="7" column="1">design of a checkers learning program:</region>
      <region class="DoCO:TextChunk" id="70" confidence="possible" page="7" column="1">Partial Task T: playing checkers Performance measure P : percent of games won in the world tournament Training experience E: games played against itself Targetfunction: V:Board + 8 Targetfunction representation</region>
      <region class="DoCO:TextChunk" id="88" page="7" column="1">The first three items above correspond to the specification of the learning task, whereas the final two items constitute design choices for the implementation of the learning program. Notice the net effect of this set of design choices is to reduce the problem of learning a checkers strategy to the problem of learning values for the coefficients wo through w 6 in the target function representation. <marker type="block"/> In order to learn the target function we require a set of training examples, each describing a specific board state b and the training value Vtrain(b) for b. In other words, each training example is an ordered pair of the form (b, V,,,i,(b)). For instance, the following training example describes a board state b in which black has won the game (note x2 = 0 indicates that red has no remaining pieces) and for which the target function value VZrain(b) is therefore +100.<marker type="page" number="8"/><marker type="block"/> Below we describe a procedure that first derives such training examples from the indirect training experience available to the learner, then adjusts the weights wi to best fit these training examples.<marker type="block"/> Recall that according to our formulation of the learning problem, the only training information available to our learner is whether the game was eventually won or lost. On the other hand, we require training examples that assign specific scores to specific board states. While it is easy to assign a value to board states that correspond to the end of the game, it is less obvious how to assign training values to the more numerous intermediate board states that occur before the game's end. Of course the fact that the game was eventually won or lost does not necessarily indicate that every board state along the game path was necessarily good or bad. For example, even if the program loses the game, it may still be the case that board states occurring early in the game should be rated very highly and that the cause of the loss was a subsequent poor move. Despite the ambiguity inherent in estimating training values for intermediate board states, one simple approach has been found to be surprisingly successful. This approach is to assign the training value of Krain(b) for any intermediate board state b to be ?(~uccessor(b)), where ? is the learner's current approximation to V and where Successor(b) denotes the next board state following b for which it is again the program's turn to move (i.e., the board state following the program's move and the opponent's response). This rule for estimating training values can be summarized as<marker type="block"/> While it may seem strange to use the current version of to estimate training values that will be used to refine this very same function, notice that we are using estimates of the value of the Successor(b) to estimate the value of board state b. In- tuitively, we can see this will make sense if ? tends to be more accurate for board states closer to game's end. In fact, under certain conditions (discussed in Chapter 13) the approach of iteratively estimating training values based on estimates of successor state values can be proven to converge toward perfect estimates of<marker type="block"/> All that remains is to specify the learning algorithm for choosing the weights wi best fit the set of training examples { ( b , Vtrain(b))}. As a first step we must define what we mean by the bestfit to the training data. One common approach is to define the best hypothesis, or set of weights, as that which minimizes the squarg error E between the training values and the values predicted by the hypothesis V<marker type="page" number="9"/><marker type="block"/> Thus, we seek the weights, or equivalently the c , that minimize E for the observed training examples. Chapter 6 discusses settings in which minimizing the sum of squared errors is equivalent to finding the most probable hypothesis given the observed training data. Several algorithms are known for finding weights of a linear function that minimize E defined in this way. In our case, we require an algorithm that will incrementally refine the weights as new training examples become available and that will be robust to errors in these estimated training values. One such algorithm is called the least mean squares, or LMS training rule. For each observed training example it adjusts the weights a small amount in the direction that reduces the error on this training example. As discussed in Chapter 4, this algorithm can be viewed as performing a stochastic gradient-descent search through the space of possible hypotheses (weight values) to minimize the squared enor E. The LMS algorithm is defined as follows:</region>
      <region class="unknown" id="72" page="7" column="1">1.2.4 Choosing a Function Approximation Algorithm f</region>
      <region class="DoCO:FigureBox" id="Fx74">
        <image class="DoCO:Figure" src="11ez.page_007.image_07.png" thmb="11ez.page_007.image_07-thumb.png"/>
      </region>
      <outsider class="DoCO:TextBox" type="page_nr" id="75" page="8" column="1">10</outsider>
      <outsider class="DoCO:TextBox" type="header" id="76" page="8" column="1">MACHINE LEARNING</outsider>
      <region class="unknown" id="78" page="8" column="1">1.2.4.1 ESTIMATING TRAINING VALUES</region>
      <region class="unknown" id="80" page="8" column="1">~ulk for estimating training values. V,,,i. (b) c c(~uccessor(b)) f</region>
      <region class="unknown" id="82" page="8" column="1">Vtrain.</region>
      <region class="unknown" id="83" page="8" column="1">1.2.4.2 ADJUSTING THE WEIGHTS</region>
      <region class="unknown" id="84" page="8" column="1">to^</region>
      <region class="unknown" id="86" page="8" column="1">.</region>
      <region class="DoCO:FigureBox" id="Fx87">
        <image class="DoCO:Figure" src="11ez.page_008.image_08.png" thmb="11ez.page_008.image_08-thumb.png"/>
      </region>
      <region class="unknown" id="89" page="9" column="1">LMS weight update rule. For each training example (b, Kmin(b))</region>
      <region class="unknown" id="90" page="9" column="1">Use the current weights to calculate ?(b) each weight mi, update it as</region>
      <region class="DoCO:TextChunk" id="91" confidence="possible" page="9" column="1">For</region>
      <region class="DoCO:TextChunk" id="95" page="9" column="1">Here q is a small constant (e.g., 0.1) that moderates the size of the weight update. To get an intuitive understanding for why this weight update rule works, notice that when the error (Vtrain(b) - c(b)) is zero, no weights are changed. When (V,,ain(b) - e(b)) is positive (i.e., when f ( b ) is too low), then each weight is increased in proportion to the value of its corresponding feature. This will raise the value of ?(b), reducing the error. Notice that if the value of some feature xi is zero, then its weight is not altered regardless of the error, so that the only weights updated are those whose features actually occur on the training example board. Surprisingly, in certain settings this simple weight-tuning method can be proven to converge to the least squared error approximation to the &amp;,in values (as discussed in Chapter 4). <marker type="block"/> The final design of our checkers learning system can be naturally described by four distinct program modules that represent the central components in many learning systems. These four modules, summarized in <xref ref-type="fig" rid="F1.1" id="94" class="deo:Reference">Figure 1.1</xref>, are as follows:</region>
      <region class="unknown" id="93" page="9" column="1">1.2.5 The Final Design</region>
      <region class="unknown" id="96" page="9" column="1">0</region>
      <region class="DoCO:TextChunk" id="97" confidence="possible" page="9" column="1">The Performance System is the module that must solve the given performance task, in this case playing checkers, by using the learned target function(s). It takes an instance of a new problem (new game) as input and produces a trace of its solution (game history) as output. In our case, the</region>
      <region class="DoCO:FigureBox" id="Fx98">
        <image class="DoCO:Figure" src="11ez.page_009.image_09.png" thmb="11ez.page_009.image_09-thumb.png"/>
      </region>
    </body>
  </article>
</pdfx>
